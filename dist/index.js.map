{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;;;;;;;ACDA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../../.nvm/versions/node/v22.18.0/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack/bootstrap","../webpack/runtime/compat","../external node-commonjs \"crypto\"",".././src/index.js"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"crypto\");","import github from \"@actions/github\";\nimport axios from \"axios\";\nimport * as cheerio from \"cheerio\";\nimport crypto from \"crypto\";\n\nconst URL = process.env[\"INPUT_URL\"];\nconst SELECTOR = process.env[\"INPUT_SELECTOR\"];\n\nconst DISCORD_WEBHOOK_URL = process.env[\"INPUT_DISCORD-WEBHOOK-URL\"];\nconst SLACK_WEBHOOK_URL = process.env[\"INPUT_SLACK-WEBHOOK-URL\"];\n\nasync function getContentHash(url, selector) {\n    let html;\n    try {\n        html = await axios.get(url).then((res) => res.data);\n    } catch (error) {\n        console.error(`Error fetching URL ${URL}:`, error);\n        process.exit(1);\n    }\n\n    let content = \"\";\n    if (selector) {\n        const $ = cheerio.load(html);\n        const elements = $(selector);\n        for (const element of elements) {\n            content += $(element).html();\n        }\n    } else {\n        content = html;\n    }\n\n    const hash = crypto.createHash(\"sha256\").update(content).digest(\"base64\");\n    return hash;\n}\n\nasync function getLastContentHash() {\n    const octokit = github.getOctokit(process.env.GH_TOKEN);\n    const [owner, repo] = process.env.GITHUB_REPOSITORY.split(\"/\");\n\n    const actionId = crypto.createHash(\"sha256\").update(process.env.GITHUB_ACTION).digest(\"hex\");\n    const variable = `__WEBSITE_CHANGE_MONITOR_ACTION__${actionId}`;\n\n    try {\n        const res = await octokit.request(`GET /repos/${owner}/${repo}/actions/variables/${variable}`, {\n            headers: {\n                \"X-GitHub-Api-Version\": \"2022-11-28\",\n            },\n        });\n        return res.data.value;\n    } catch (error) {\n        return null;\n    }\n}\n\nasync function saveContentHash(hash) {\n    const octokit = github.getOctokit(process.env.GH_TOKEN);\n    const [owner, repo] = process.env.GITHUB_REPOSITORY.split(\"/\");\n\n    const actionId = crypto.createHash(\"sha256\").update(process.env.GITHUB_ACTION).digest(\"hex\");\n    const variableName = `__WEBSITE_CHANGE_MONITOR_ACTION__${actionId}`;\n\n    let shouldCreate = true;\n    const response = await octokit.request(`GET /repos/${owner}/${repo}/actions/variables`, {\n        headers: {\n            \"X-GitHub-Api-Version\": \"2022-11-28\",\n        },\n    });\n\n    for (const repoVariable of response.data.variables) {\n        if (repoVariable.name.toUpperCase() === variableName.toUpperCase()) {\n            shouldCreate = false;\n            break;\n        }\n    }\n\n    if (shouldCreate) {\n        await octokit.request(`POST /repos/${owner}/${repo}/actions/variables`, {\n            name: variableName,\n            value: hash,\n            headers: {\n                \"X-GitHub-Api-Version\": \"2022-11-28\",\n            },\n        });\n    } else {\n        await octokit.request(`PATCH /repos/${owner}/${repo}/actions/variables/${variableName}`, {\n            value: hash,\n            headers: {\n                \"X-GitHub-Api-Version\": \"2022-11-28\",\n            },\n        });\n    }\n}\n\nasync function notifyDiscord(url, content) {\n    await axios.post(url, { content }, { headers: { \"Content-Type\": \"application/json\" } });\n}\n\nasync function notifySlack(url, content) {\n    await axios.post(url, { text: content }, { headers: { \"Content-Type\": \"application/json\" } });\n}\n\nasync function notify(url) {\n    const content = `Website ${url} has changed!`;\n    if (DISCORD_WEBHOOK_URL) {\n        await notifyDiscord(DISCORD_WEBHOOK_URL, content);\n    }\n    if (SLACK_WEBHOOK_URL) {\n        await notifySlack(SLACK_WEBHOOK_URL, content);\n    }\n}\n\nasync function main() {\n    const hash = await getContentHash(URL, SELECTOR);\n    const previousHash = await getLastContentHash(URL);\n    if (hash === previousHash) {\n        console.log(\"No changes detected.\");\n        return;\n    } else {\n        console.log(\"Changes detected. Sending notification.\");\n        await Promise.all([notify(URL), saveContentHash(hash)]);\n    }\n}\n\nmain();\n"],"names":[],"sourceRoot":""}